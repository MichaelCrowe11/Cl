import { NextRequest, NextResponse } from 'next/server';
import { tmpdir } from 'os';
import { mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import archiver from 'archiver';

interface ScaffoldOptions {
  projectName: string;
  strains: string[];
  equipment: string[];
  force?: boolean;
}

// MycoIDE Project Template Generator
function generateMycoIDEProject(outDir: string, options: ScaffoldOptions) {
  const { projectName, strains, equipment } = options;
  
  // Create directory structure
  const dirs = [
    'batches',
    'protocols',
    'analysis',
    'reports',
    'docs',
    'config',
    'scripts',
    'data/raw',
    'data/processed',
    'models'
  ];
  
  dirs.forEach(dir => {
    mkdirSync(join(outDir, dir), { recursive: true });
  });
  
  // Generate project metadata
  const projectMeta = {
    name: projectName,
    version: process.env.MYCOIDE_VERSION || '1.0.0',
    created: new Date().toISOString(),
    strains: strains,
    equipment: equipment,
    mycoide_version: '1.0.0'
  };
  
  writeFileSync(
    join(outDir, '.mycoide_project.json'),
    JSON.stringify(projectMeta, null, 2)
  );
  
  // Generate sample batch files
  strains.forEach((strain, index) => {
    const batchId = `CLX-${strain.substring(0, 2).toUpperCase()}${String(index + 1).padStart(3, '0')}`;
    const batchDir = join(outDir, 'batches', batchId);
    mkdirSync(batchDir, { recursive: true });
    
    const batchMeta = {
      batch_id: batchId,
      strain: strain,
      inoculation_date: new Date().toISOString().split('T')[0],
      substrate: 'Straw pellets',
      status: 'inoculated',
      target_weight: 50,
      expected_harvest: new Date(Date.now() + 21 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
    };
    
    writeFileSync(
      join(batchDir, 'meta.yaml'),
      `# Batch Metadata
batch_id: ${batchMeta.batch_id}
strain: ${batchMeta.strain}
inoculation_date: ${batchMeta.inoculation_date}
substrate: ${batchMeta.substrate}
status: ${batchMeta.status}
target_weight: ${batchMeta.target_weight}
expected_harvest: ${batchMeta.expected_harvest}

# Equipment used
equipment:
${equipment.map(eq => `  - ${eq}`).join('\n')}

# Growth tracking
growth_log:
  - date: ${batchMeta.inoculation_date}
    weight: 0.0
    notes: "Initial inoculation"
`
    );
    
    // Generate Python analysis script for this batch
    const analysisScript = `#!/usr/bin/env python3
"""
Batch Analysis Script for ${batchId}
Generated by MycoIDE Scaffold v${projectMeta.version}
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import yaml

class BatchAnalyzer:
    def __init__(self, batch_id: str):
        self.batch_id = batch_id
        self.batch_dir = f"../../batches/{batch_id}"
        self.meta = self.load_metadata()
    
    def load_metadata(self):
        """Load batch metadata from YAML file."""
        with open(f"{self.batch_dir}/meta.yaml", 'r') as f:
            return yaml.safe_load(f)
    
    def load_growth_data(self):
        """Load growth tracking data."""
        # In real implementation, load from CSV or database
        growth_log = self.meta.get('growth_log', [])
        return pd.DataFrame(growth_log)
    
    def analyze_growth_rate(self):
        """Calculate growth rate and trends."""
        df = self.load_growth_data()
        if len(df) < 2:
            return {"status": "insufficient_data"}
        
        df['date'] = pd.to_datetime(df['date'])
        df['days_since_inoculation'] = (df['date'] - df['date'].iloc[0]).dt.days
        
        # Calculate daily growth rate
        daily_growth = df['weight'].diff().fillna(0)
        avg_growth_rate = daily_growth.mean()
        
        return {
            "avg_daily_growth": avg_growth_rate,
            "current_weight": df['weight'].iloc[-1],
            "days_elapsed": df['days_since_inoculation'].iloc[-1],
            "projected_harvest": self.predict_harvest_date(df)
        }
    
    def predict_harvest_date(self, df):
        """Predict harvest date based on growth trends."""
        target_weight = self.meta.get('target_weight', 50)
        current_weight = df['weight'].iloc[-1]
        
        if len(df) < 3:
            return "insufficient_data"
        
        # Simple linear regression for prediction
        recent_data = df.tail(5)
        growth_rate = recent_data['weight'].diff().mean()
        
        if growth_rate <= 0:
            return "growth_stalled"
        
        days_to_harvest = (target_weight - current_weight) / growth_rate
        harvest_date = datetime.now() + timedelta(days=days_to_harvest)
        
        return harvest_date.strftime('%Y-%m-%d')
    
    def generate_report(self):
        """Generate analysis report."""
        analysis = self.analyze_growth_rate()
        
        report = f'''
# Batch Analysis Report: {self.batch_id}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Batch Information
- Strain: {self.meta.get('strain', 'Unknown')}
- Inoculation Date: {self.meta.get('inoculation_date', 'Unknown')}
- Current Status: {self.meta.get('status', 'Unknown')}

## Growth Analysis
- Current Weight: {analysis.get('current_weight', 0):.2f}g
- Average Daily Growth: {analysis.get('avg_daily_growth', 0):.3f}g/day
- Days Since Inoculation: {analysis.get('days_elapsed', 0)}
- Projected Harvest Date: {analysis.get('projected_harvest', 'TBD')}

## Recommendations
- Monitor daily weight changes
- Maintain optimal environmental conditions
- Check for contamination signs
'''
        
        # Save report
        with open(f"{self.batch_dir}/analysis_report.md", 'w') as f:
            f.write(report)
        
        return report

if __name__ == "__main__":
    analyzer = BatchAnalyzer("${batchId}")
    report = analyzer.generate_report()
    print(report)
`;
    
    writeFileSync(
      join(outDir, 'analysis', `${batchId}_analysis.py`),
      analysisScript
    );
  });
  
  // Generate main project README
  const readme = `# ${projectName} - MycoIDE Project

A professional mycology cultivation project generated by MycoIDE Scaffold.

## Project Structure

\`\`\`
${projectName}/
├── batches/           # Individual cultivation batches
│   └── CLX-*/         # Batch-specific data and tracking
├── protocols/         # Standard operating procedures
├── analysis/          # Analysis scripts and notebooks
├── reports/           # Generated reports and documentation
├── docs/             # Project documentation
├── config/           # Configuration files
├── scripts/          # Utility scripts
├── data/             # Raw and processed data
└── models/           # ML models and predictions
\`\`\`

## Tracked Strains
${strains.map(strain => `- ${strain}`).join('\n')}

## Equipment
${equipment.map(eq => `- ${eq}`).join('\n')}

## Getting Started

1. Install dependencies:
   \`\`\`bash
   pip install -r requirements.txt
   \`\`\`

2. Run batch analysis:
   \`\`\`bash
   cd analysis
   python CLX-*_analysis.py
   \`\`\`

3. Generate reports:
   \`\`\`bash
   python scripts/generate_reports.py
   \`\`\`

## MycoIDE Integration

This project is compatible with MycoIDE v${projectMeta.version}.
Load this project in MycoIDE for advanced analysis and monitoring.

Generated on: ${new Date().toISOString()}
`;

  writeFileSync(join(outDir, 'README.md'), readme);
  
  // Generate requirements.txt
  const requirements = `# MycoIDE Project Dependencies
pandas>=1.5.0
numpy>=1.21.0
matplotlib>=3.5.0
scipy>=1.9.0
pyyaml>=6.0
jupyter>=1.0.0
scikit-learn>=1.1.0
seaborn>=0.11.0
plotly>=5.0.0

# Optional: Advanced ML libraries
tensorflow>=2.9.0
torch>=1.12.0
xgboost>=1.6.0
`;

  writeFileSync(join(outDir, 'requirements.txt'), requirements);
  
  // Generate configuration file
  const config = {
    project: projectMeta,
    monitoring: {
      check_interval: 3600,
      alert_thresholds: {
        temperature: { min: 20, max: 28 },
        humidity: { min: 80, max: 95 },
        contamination_risk: 0.3
      }
    },
    analysis: {
      auto_generate_reports: true,
      report_frequency: 'daily',
      ml_predictions: true
    }
  };
  
  writeFileSync(
    join(outDir, 'config', 'mycoide.json'),
    JSON.stringify(config, null, 2)
  );
}

export async function POST(req: NextRequest) {
  try {
    const { projectName = 'MycoProject', strains = ['Oyster', 'Shiitake'], equipment = ['Sterilizer', 'Incubator'], force = false } = await req.json();
    
    // Create temporary directory
    const timestamp = Date.now();
    const outDir = join(tmpdir(), `mycoide-${timestamp}`);
    
    // Generate project structure
    generateMycoIDEProject(outDir, { projectName, strains, equipment, force });
    
    // Create ZIP archive
    return new Promise<NextResponse>((resolve, reject) => {
      const archive = archiver('zip', { zlib: { level: 9 } });
      const chunks: Uint8Array[] = [];
      
      archive.on('data', (chunk: Uint8Array) => {
        chunks.push(chunk);
      });
      
      archive.on('end', () => {
        const buffer = Buffer.concat(chunks);
        const response = new NextResponse(buffer, {
          headers: {
            'Content-Type': 'application/zip',
            'Content-Disposition': `attachment; filename="${projectName}.zip"`,
            'Content-Length': buffer.length.toString(),
          },
        });
        resolve(response);
      });
      
      archive.on('error', (err: Error) => {
        reject(new NextResponse('Archive creation failed', { status: 500 }));
      });
      
      archive.directory(outDir, false);
      archive.finalize();
    });
    
  } catch (error) {
    console.error('Scaffold generation error:', error);
    return new NextResponse('Scaffold generation failed', { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({
    message: 'MycoIDE Scaffold Generator API',
    version: process.env.MYCOIDE_VERSION || '1.0.0',
    endpoints: {
      POST: '/api/scaffold - Generate project scaffold',
    },
    example_payload: {
      projectName: 'MyMushroomFarm',
      strains: ['Oyster', 'Shiitake', 'Lions Mane'],
      equipment: ['Sterilizer', 'Incubator', 'pH Meter'],
      force: false
    }
  });
}
